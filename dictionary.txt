##################################################
                     СЛОВАРЬ
##################################################
Словарь (его еще называют ассоциативным списком) – неупорядоченная совокупность произвольных объектов с доступом по ключу.
Вот все способы создать словарь:
a = dict(one=1, two=2, three=3)

b = {'one': 1, 'two': 2, 'three': 3}

c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))

d = dict([('two', 2), ('one', 1), ('three', 3)])

e = dict({'three': 3, 'one': 1, 'two': 2})

f = dict({'one': 1, 'three': 3}, two=2)

Внутри функции dict() необязательно использавать ковычки для названия ключей, она сделает это за вас.
Ввод : d = dict(artem = 39,yulia = 37)
Вывод : {'artem': 39, 'yulia': 37}
Словари как и списки поддерживают операцию индексации, только вместо индекса нужно указывать значения ключа.
У словарей вообще нету понятия индекса, потому что словари - это неупорядоченная коллекция данных.
Поэтому обращаться можно только по ключу через квадратные скобки
Например:
d['artem'] - вернет значение ключа т.е 39
Для того, чтобы добавить новое значение в словарь необходимо обратится по новому ключу и присвоить туда значение вот в таком формате:
d[новый ключ] = значение
Если присвоить новое значение уже существующему ключу, то мы просто заменим старое значение.
Значит в словаре не может быть двух пар с одинаковыми ключами.
И раз мы смогли изменить существующий элемент словаря, значит можно сделать вывод что
словарь является изменяемым объектом
Для того, чтобы удалить значение из словаря необходимо воспользоваться функцией del и обратится по ключу у словаря
Например: del d['artem'] удалит из словаря d и ключ и его значение
При попытке удалить ключ, которого нет в словаре,  возникнет ошибка KeyError.
Требования к ключу словаря

Есть важная особенность при работе с ключами словаря, которую нужно запомнить, а именно
Ключом может быть только неизменяемый объект
К неизменяемым объектам относятся:
    целые(тип int) и вещественные(тип float) числа
    строки (тип str)
    None
    кортежи (тип tuple)
    неизменяемые множества (тип frozenset) (Еще не проходили, разберем в этом модуле)
К изменяемым объектам относятся:

    списки (тип list)
    множества (тип set) (Еще не проходили, разберем в этом модуле)
    сами словари (тип dict)
Из этого следует, что ключом словаря не может быть список, множество или словарь.
Если попытаетесь использовать изменяемый тип в качестве ключа, получите ошибку TypeError: unhashable type
В качестве значения словаря может выступать любой тип данных.
я без проблем могу изменять файл прямо на гитхабе

Операции со словарями

Функция len() помогает найти «длину» словаря (под длиной у словаря понимается количество пар «ключ: значение»)
Оператор in позволяет проверить входит ли ключ со значение х  в словарь d.
Он вернет True – когда ключ есть в словаре, в обратном случае – False.
Если хотите получить противоположный результат, используйте not in
При помощи функции list можно преобразовать словарь в список, но есть одна особенность: получится список только из ключей
Словари можно сравнивать между собой, но сравнение допустимо только на равенство == и неравенство !=.
Словари будут считаться равными, если они имеют одинаковое количество пар (ключ: значение) и при этом в соответствующей паре совпадают и ключ и значение.
Сравнение при помощи операторов > < >= <= приведет к ошибке TypeError.
Также обратите внимание, что мы сравнивали словари только со словарями. Попытка сравнить словарь с другим типом данных (списком, строкой, числом и т.д.) приведет вновь к ошибке TypeError.
Можно объединять пары ключ-значения при помощи операции слияния |.
dict_1 | dict_2
dict_1 = {'John': 15, 'Rick': 10, 'Misa' : 12 }
dict_2 = {'Bonnie': 18,'Rick': 20}
dict_3 = dict_1 | dict_2
dict_3 = {'John': 15, 'Rick': 20, 'Misa': 12, 'Bonnie': 18}
dict_4 = dict_2 | dict_1
dict_4 = {'Bonnie': 18, 'Rick': 10, 'John': 15, 'Misa': 12}
К значениям словаря, стоящего слева, будут добавляться значения словаря, стоящего справа от знака операции.
При совпадении ключей будет браться значения из правого словаря. Поэтому для этой операции важно на каком месте стоят словари

Методы словаря

Метод .clear() очищает весь словарь. В итоге после вызова получится пустой словарь
Метод get() – позволяет получить значение ключа.  Нужно указать внутри скобок один аргумент – ключ, значение которого хотим получить.
Если ключа в словаре нет, то выведет None, но если в метод get() внести второй аргумент, то вместо None будет появляться это значение:
d = {1: 'one', 2: 'two', 3: 'three'}
print(d.get(1))
one
print(d.get(5))
None
print(d.get(5, 'No such key'))
No such key
Метод setdefault()  - получает значение ключа. Похож на прошлый метод get(), однако при обращении к несуществующему ключу он вносит в словарь новую пару ключ-значение.
Значением будет второй аргумент, который был передан в этот метод, либо же None, если в методе только один аргумент:
d = {1: 'one', 2: 'two', 3: 'three'}
print(d.setdefault(1))
one
print(d.setdefault(6))
None
print(d)
{1: 'one', 2: 'two', 3: 'three', 6: None}
Метод pop() – возвращает значение, находящееся под указанным ключом, а из самого словаря удаляется пара с данным ключом:
d = {1: 'one', 2: 'two', 3: 'three'}
print(d.pop(2))
two
print(d)
{1: 'one', 3: 'three'}
Вызов метода без указания ключа, либо же без существующего ключа, приводит к ошибке TypeError.
Метод keys() позволяет получить все ключи словаря.
Метод values() позволяет получить все значения словаря.
Метод items() – возвращает коллекцию, в которой содержатся все пары «ключ-значение» в виде кортежей.
Метод update() обновляет словарь элементами из другого словаря.
Другими словами, метод сливает(мержит от английского «merge») один словарь в другой:
добавляются новые ключи из другого словаря, при совпадении ключей записывается значение из переданного словаря.
d1 = {'a': 100, 'b': 200, 'c': 333}
d2 = {'x': 300, 'y': 200, 'z': 777}
d2.update(d1)
print(d2)
{'x': 300, 'y': 200, 'z': 777, 'a': 100, 'b': 200, 'c': 333}

Словари относятся к коллекциям как и списки, строки и кортежи.
Все коллекции объединяет то, что по их элементам можно итерироваться: обходить элементы коллекции при помощи цикла for.
По умолчанию в словаре используются ключи в качестве значений при итерации цикла for.
Но что, если мы хотим итерироваться не по ключам, а по значениям словаря. Так тоже можно делать, причем двумя способами:
1.итерироваться по ключам, и обращаться через них по значениям.
for key in lang.keys():
  print(lang[key])
2.использовать метод values
for value in lang.values():
  print(value)
А можно сразу итерироваться и по ключу и по его значению, спросите Вы? Конечно! Используйте метод items.
for item in lang.items():
  print(item, f'Key={item[0]}, value={item[1]}')

